#![allow(dead_code)]
extern crate num;
extern crate primal;
extern crate rayon;
#[macro_use]
extern crate itertools;

use rayon::prelude::*;

/// Problem 1: Multiples of 3 and 5
///
/// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
/// The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
fn problem_one() -> String {
    let val: u64 = (0..1000u64)
        .into_par_iter()
        .filter(|x| x % 3 == 0 || x % 5 == 0)
        .sum();

    format!("{}", val)
}

/// Problem 2: Even fibonacci numbers
///
/// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By
/// starting with 1 and 2, the first 10 terms will be:
///
///     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
///
/// By considering the terms in the Fibonacci sequence whose values do not exceed four million,
/// find the sum of the even-valued terms.
fn problem_two() -> String {
    let mut sum: u64 = 0;
    let mut last_val: u64 = 0;
    let mut curr_val: u64 = 1;

    loop {
        let new_val = last_val + curr_val;

        if new_val > 4_000_000 {
            break;
        }

        if new_val % 2 == 0 {
            sum += new_val;
        }

        last_val = curr_val;
        curr_val = new_val;
    }

    format!("{}", sum)
}

/// Problem 3: Largest prime factor
///
/// The prime factors of 13195 are 5, 7, 13 and 29.
/// What is the largest prime factor of the number 600851475143?
fn problem_three() -> String {
    #[allow(clippy::unreadable_literal)]
    let n = 600851475143;
    let sieve = primal::Sieve::new(1_000_000_000);
    let div = sieve.factor(n).unwrap().iter().map(|x| x.0).max().unwrap();

    format!("{:?}", div)
}

/// Problem 4: Largest palindrome product
///
/// A palindromic number reads the same both ways. The largest palindrome made from the product of
/// two 2-digit numbers is 9009 = 91 × 99.
///
/// Find the largest palindrome made from the product of two 3-digit numbers.
fn problem_four() -> String {
    // starting from the largest two
    let r1 = (100..1000_usize).rev();
    let r2 = (100..1000_usize).rev();

    let big_pal = iproduct!(r1, r2)
        .filter_map(|(x, y)| {
            let product = x * y;

            if is_palindrome(product) {
                Some(product)
            } else {
                None
            }
        })
        .max()
        .unwrap();

    format!("{:?}", big_pal)
}

fn num_to_bytes(num: usize) -> Vec<usize> {
    fn x_inner(n: usize, xs: &mut Vec<usize>) {
        if n >= 10 {
            x_inner(n / 10, xs)
        };
        xs.push(n % 10);
    }

    let mut xs = Vec::new();
    x_inner(num, &mut xs);

    xs
}

fn is_palindrome(num: usize) -> bool {
    let as_bytes = num_to_bytes(num);

    let (lead, trail) = {
        let mid = as_bytes.len() / 2;
        (as_bytes[0..mid].iter(), as_bytes[mid..].iter())
    };

    !lead.zip(trail.rev()).any(|(s, b)| s != b)
}

#[test]
fn test_palindrome() {
    assert_eq!(is_palindrome(90509), true);
    assert_eq!(is_palindrome(9009), true);
    assert_eq!(is_palindrome(9967), false);
}

/// Problem 5: Smallest multiple
///
/// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without
/// any remainder. What is the smallest positive number that is evenly divisible by all of the
/// numbers from 1 to 20?
fn problem_five() -> String {
    // there is a certain order here we can use to reduce the number of comparisons required:
    //
    // The full list of numbers to check is:
    let divisors = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 4];

    let val = (20..)
        .find(|x| divisors.iter().all(|&y| x % y == 0))
        .unwrap();

    format!("{:?}", val)
}

/// Problem 6: Sum square difference
///
/// The sum of the squares of the first ten natural numbers is,
///
///     1^2 + 2^2 + ... + 10^2 = 385
///
/// The square of the sum of the first ten natural numbers is,
///
///     (1 + 2 + ... + 10)^2 = 55^2 = 3025
///
/// Hence the difference between the sum of the squares of the first ten natural numbers and the
/// square of the sum is 3025 − 385 = 2640.
///
/// Find the difference between the sum of the squares of the first one hundred natural numbers and
/// the square of the sum.
fn problem_six() -> String {
    let square_of_sums: i64 = (1_i64..101).sum::<i64>().pow(2);
    let sum_of_squares: i64 = (1_i64..101).fold(0, |acc, val| acc + val.pow(2));

    let result = (sum_of_squares - square_of_sums).abs();
    format!("{}", result)
}

/// Problem 7: 10,001st prime
///
/// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime
/// is 13. What is the 10 001st prime number?
fn problem_seven() -> String {
    format!("{}", primal::Primes::all().nth(10001 - 1).unwrap())
}

/// Problem 8: Largest product in a series
///
/// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8
/// × 9 = 5832.
///
/// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What
/// is the value of this product?
fn problem_eight() -> String {
    let digits: [u64; 1000] = [
        7, 3, 1, 6, 7, 1, 7, 6, 5, 3, 1, 3, 3, 0, 6, 2, 4, 9, 1, 9, 2, 2, 5, 1, 1, 9, 6, 7, 4, 4,
        2, 6, 5, 7, 4, 7, 4, 2, 3, 5, 5, 3, 4, 9, 1, 9, 4, 9, 3, 4, 9, 6, 9, 8, 3, 5, 2, 0, 3, 1,
        2, 7, 7, 4, 5, 0, 6, 3, 2, 6, 2, 3, 9, 5, 7, 8, 3, 1, 8, 0, 1, 6, 9, 8, 4, 8, 0, 1, 8, 6,
        9, 4, 7, 8, 8, 5, 1, 8, 4, 3, 8, 5, 8, 6, 1, 5, 6, 0, 7, 8, 9, 1, 1, 2, 9, 4, 9, 4, 9, 5,
        4, 5, 9, 5, 0, 1, 7, 3, 7, 9, 5, 8, 3, 3, 1, 9, 5, 2, 8, 5, 3, 2, 0, 8, 8, 0, 5, 5, 1, 1,
        1, 2, 5, 4, 0, 6, 9, 8, 7, 4, 7, 1, 5, 8, 5, 2, 3, 8, 6, 3, 0, 5, 0, 7, 1, 5, 6, 9, 3, 2,
        9, 0, 9, 6, 3, 2, 9, 5, 2, 2, 7, 4, 4, 3, 0, 4, 3, 5, 5, 7, 6, 6, 8, 9, 6, 6, 4, 8, 9, 5,
        0, 4, 4, 5, 2, 4, 4, 5, 2, 3, 1, 6, 1, 7, 3, 1, 8, 5, 6, 4, 0, 3, 0, 9, 8, 7, 1, 1, 1, 2,
        1, 7, 2, 2, 3, 8, 3, 1, 1, 3, 6, 2, 2, 2, 9, 8, 9, 3, 4, 2, 3, 3, 8, 0, 3, 0, 8, 1, 3, 5,
        3, 3, 6, 2, 7, 6, 6, 1, 4, 2, 8, 2, 8, 0, 6, 4, 4, 4, 4, 8, 6, 6, 4, 5, 2, 3, 8, 7, 4, 9,
        3, 0, 3, 5, 8, 9, 0, 7, 2, 9, 6, 2, 9, 0, 4, 9, 1, 5, 6, 0, 4, 4, 0, 7, 7, 2, 3, 9, 0, 7,
        1, 3, 8, 1, 0, 5, 1, 5, 8, 5, 9, 3, 0, 7, 9, 6, 0, 8, 6, 6, 7, 0, 1, 7, 2, 4, 2, 7, 1, 2,
        1, 8, 8, 3, 9, 9, 8, 7, 9, 7, 9, 0, 8, 7, 9, 2, 2, 7, 4, 9, 2, 1, 9, 0, 1, 6, 9, 9, 7, 2,
        0, 8, 8, 8, 0, 9, 3, 7, 7, 6, 6, 5, 7, 2, 7, 3, 3, 3, 0, 0, 1, 0, 5, 3, 3, 6, 7, 8, 8, 1,
        2, 2, 0, 2, 3, 5, 4, 2, 1, 8, 0, 9, 7, 5, 1, 2, 5, 4, 5, 4, 0, 5, 9, 4, 7, 5, 2, 2, 4, 3,
        5, 2, 5, 8, 4, 9, 0, 7, 7, 1, 1, 6, 7, 0, 5, 5, 6, 0, 1, 3, 6, 0, 4, 8, 3, 9, 5, 8, 6, 4,
        4, 6, 7, 0, 6, 3, 2, 4, 4, 1, 5, 7, 2, 2, 1, 5, 5, 3, 9, 7, 5, 3, 6, 9, 7, 8, 1, 7, 9, 7,
        7, 8, 4, 6, 1, 7, 4, 0, 6, 4, 9, 5, 5, 1, 4, 9, 2, 9, 0, 8, 6, 2, 5, 6, 9, 3, 2, 1, 9, 7,
        8, 4, 6, 8, 6, 2, 2, 4, 8, 2, 8, 3, 9, 7, 2, 2, 4, 1, 3, 7, 5, 6, 5, 7, 0, 5, 6, 0, 5, 7,
        4, 9, 0, 2, 6, 1, 4, 0, 7, 9, 7, 2, 9, 6, 8, 6, 5, 2, 4, 1, 4, 5, 3, 5, 1, 0, 0, 4, 7, 4,
        8, 2, 1, 6, 6, 3, 7, 0, 4, 8, 4, 4, 0, 3, 1, 9, 9, 8, 9, 0, 0, 0, 8, 8, 9, 5, 2, 4, 3, 4,
        5, 0, 6, 5, 8, 5, 4, 1, 2, 2, 7, 5, 8, 8, 6, 6, 6, 8, 8, 1, 1, 6, 4, 2, 7, 1, 7, 1, 4, 7,
        9, 9, 2, 4, 4, 4, 2, 9, 2, 8, 2, 3, 0, 8, 6, 3, 4, 6, 5, 6, 7, 4, 8, 1, 3, 9, 1, 9, 1, 2,
        3, 1, 6, 2, 8, 2, 4, 5, 8, 6, 1, 7, 8, 6, 6, 4, 5, 8, 3, 5, 9, 1, 2, 4, 5, 6, 6, 5, 2, 9,
        4, 7, 6, 5, 4, 5, 6, 8, 2, 8, 4, 8, 9, 1, 2, 8, 8, 3, 1, 4, 2, 6, 0, 7, 6, 9, 0, 0, 4, 2,
        2, 4, 2, 1, 9, 0, 2, 2, 6, 7, 1, 0, 5, 5, 6, 2, 6, 3, 2, 1, 1, 1, 1, 1, 0, 9, 3, 7, 0, 5,
        4, 4, 2, 1, 7, 5, 0, 6, 9, 4, 1, 6, 5, 8, 9, 6, 0, 4, 0, 8, 0, 7, 1, 9, 8, 4, 0, 3, 8, 5,
        0, 9, 6, 2, 4, 5, 5, 4, 4, 4, 3, 6, 2, 9, 8, 1, 2, 3, 0, 9, 8, 7, 8, 7, 9, 9, 2, 7, 2, 4,
        4, 2, 8, 4, 9, 0, 9, 1, 8, 8, 8, 4, 5, 8, 0, 1, 5, 6, 1, 6, 6, 0, 9, 7, 9, 1, 9, 1, 3, 3,
        8, 7, 5, 4, 9, 9, 2, 0, 0, 5, 2, 4, 0, 6, 3, 6, 8, 9, 9, 1, 2, 5, 6, 0, 7, 1, 7, 6, 0, 6,
        0, 5, 8, 8, 6, 1, 1, 6, 4, 6, 7, 1, 0, 9, 4, 0, 5, 0, 7, 7, 5, 4, 1, 0, 0, 2, 2, 5, 6, 9,
        8, 3, 1, 5, 5, 2, 0, 0, 0, 5, 5, 9, 3, 5, 7, 2, 9, 7, 2, 5, 7, 1, 6, 3, 6, 2, 6, 9, 5, 6,
        1, 8, 8, 2, 6, 7, 0, 4, 2, 8, 2, 5, 2, 4, 8, 3, 6, 0, 0, 8, 2, 3, 2, 5, 7, 5, 3, 0, 4, 2,
        0, 7, 5, 2, 9, 6, 3, 4, 5, 0,
    ];

    let stride = 13;
    let max_product: Option<u64> = (0..digits.len() - stride)
        .into_par_iter()
        .map(|x| digits[x..x + stride].iter().product())
        .max();

    format!("{:?}", max_product.unwrap())
}

/// Problem 9: Special Pythagorean triplet
///
/// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
///
///     a^2 + b^2 = c^2
///
/// For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
///
/// There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc.
fn problem_nine() -> String {
    let (a, b, c) = iproduct!((0_u32..1000), (0_u32..1000), (0_u32..1000))
        .find(|&(a, b, c)| {
            (a < b) && (b < c) && (a + b + c == 1000) && (a.pow(2) + b.pow(2) == c.pow(2))
        })
        .unwrap();

    format!("{:?}", a * b * c)
}

/// Problem 10: Summation of primes
///
/// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
/// Find the sum of all the primes below two million.
fn problem_ten() -> String {
    let sum: usize = primal::Primes::all().take_while(|&x| x < 2_000_000).sum();
    format!("{}", sum)
}

/// Problem 11: Largest product in a grid
///
/// In the 20×20 grid below (in the code), four numbers along a diagonal line have been marked in
/// red (see the site, starts at coordinates (8, 6) and goes down and to the right).
///
/// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
///
/// What is the greatest product of four adjacent numbers in the same direction (up, down, left,
/// right, or diagonally) in the 20×20 grid?
fn problem_eleven() -> String {
    #[allow(clippy::zero_prefixed_literal)]
    let raw_grid = [
        08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08,
        49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
        81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
        52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
        22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
        24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
        32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
        67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21,
        24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
        21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
        78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92,
        16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
        86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
        19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
        04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
        88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
        04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36,
        20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
        20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
        01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,
    ];

    let grid = match Grid::new(20, 20, &raw_grid) {
        Ok(x) => x,
        Err(x) => return x.to_owned(),
    };

    // multiplication is associative, so opposing cardinal directions cancel each other out and
    // don't need to be checked, therefore...
    //
    // - Direction::North for up and down
    // - Direction::East for left and right
    // - Direction::NorthEast covers left-to-right rising / right-to-left falling diagonal
    // - Direction::SouthEast covers left-to-right falling / right-to-left rising diagonal
    let directions = [Direction::North, Direction::East, Direction::NorthEast, Direction::SouthEast].iter();
    let coordinates = iproduct!((0..grid.num_rows), (0..grid.num_columns));
    let max_stride_product = iproduct!(coordinates, directions)
        .filter_map(|((x, y), d)| grid.product(&Coordinate { x, y }, 3, d))
        .max()
        .unwrap();

    format!("{}", max_stride_product)
}

#[derive(Debug, Clone)]
struct Coordinate {
    x: usize,
    y: usize,
}

#[derive(Debug)]
enum Direction {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
}

impl Direction {
    fn goes_up(&self) -> bool {
        match self {
            Direction::North
            | Direction::NorthEast
            | Direction::NorthWest => true,
            _ => false,
        }
    }

    fn goes_down(&self) -> bool {
        match self {
            Direction::South
            | Direction::SouthEast
            | Direction::SouthWest => true,
            _ => false,
        }
    }

    fn goes_right(&self) -> bool {
        match self {
            Direction::East
            | Direction::SouthEast
            | Direction::NorthEast => true,
            _ => false,
        }
    }

    fn goes_left(&self) -> bool {
        match self {
            Direction::West
            | Direction::SouthWest
            | Direction::NorthWest => true,
            _ => false,
        }
    }

    fn move_single(&self) -> (isize, isize) {
        match self {
            Direction::North => (0, -1),
            Direction::NorthEast => (1, -1),
            Direction::East => (1, 0),
            Direction::SouthEast => (1, 1),
            Direction::South => (0, 1),
            Direction::SouthWest => (-1, 1),
            Direction::West => (-1, 0),
            Direction::NorthWest => (-1, -1),
        }
    }

    fn move_stride(&self, stride: usize) -> (isize, isize) {
        let (x, y) = self.move_single();
        (x * (stride as isize), y * (stride as isize))
    }
}

struct Grid<'a> {
    raw: &'a [u8],
    num_columns: usize,
    num_rows: usize,
}

impl <'a> Grid<'a> {
    pub fn new(num_columns: usize, num_rows: usize, input: &[u8]) -> Result<Grid, &str> {
        if num_columns * num_rows > input.len() {
            return Err("invalid-grid");
        }

        let grid = Grid {
            raw: input,
            num_columns,
            num_rows,
        };

        Ok(grid)
    }

    fn coordinate_to_raw(&self, coordinate: &Coordinate) -> Option<usize> {
        let Coordinate { x, y } = coordinate;

        // if either coordinate is beyond their respective bound, return none
        if *x >= self.num_columns || *y >= self.num_rows {
            return None;
        }

        let raw = (y * self.num_columns) + x;

        if raw < self.raw.len() {
            Some(raw)
        } else {
            None
        }
    }

    pub fn value(&self, c: &Coordinate) -> Option<u8> {
        let index = self.coordinate_to_raw(&c)?;
        Some(self.raw[index])
    }

    fn next_coordinate(&self, start: &Coordinate, stride: usize, direction: &Direction) -> Option<Coordinate> {
        // this function assumes that start is already a valid coordinate
        let Coordinate { x, y } = start;
        let (inc_x, inc_y) = direction.move_stride(stride);

        let opt_inc_y = match inc_y {
            inc_y if inc_y < 0 => y.checked_sub(-inc_y as usize),
            inc_y if inc_y > 0 => y.checked_add(inc_y as usize),
            inc_y if inc_y == 0 => Some(*y),

            // above patterns actually are exhaustive, though the rust compiler
            // can't prove it, this is just to silence it
            _ => None,
        };

        let opt_inc_x = match inc_x {
            inc_x if inc_x < 0 => x.checked_sub(-inc_x as usize),
            inc_x if inc_x > 0 => x.checked_add(inc_x as usize),
            inc_x if inc_x == 0 => Some(*x),

            // above patterns actually are exhaustive, though the rust compiler
            // can't prove it, this is just to silence it
            _ => None,
        };

        // if y is near a border and trying to cross over it, return None
        let y_cross_top = (inc_y < 0) && opt_inc_y.is_none();
        let y_cross_bot = (inc_y > 0) && (*y + inc_y as usize) > (self.num_rows - 1);
        if y_cross_top || y_cross_bot {
            return None;
        }

        // if x is on a border and trying to cross over it, return none
        let x_cross_left = (inc_x < 0) && opt_inc_x.is_none();
        let x_cross_rght = (inc_x > 0) && (*x + inc_x as usize) > (self.num_columns - 1);
        if x_cross_left || x_cross_rght {
            return None;
        }

        match (opt_inc_x, opt_inc_y) {
            (Some(inc_x), Some(inc_y)) =>  Some(Coordinate { x: inc_x, y: inc_y }),
            _ => None
        }
    }

    fn coordinates_for_stride(&self, start: &Coordinate, stride: usize, d: &Direction) -> Option<Vec<Coordinate>> {
        // otherwise, get each possible coordinate, if any return None then the
        // whole return value from this function should be None, otherwise
        // return all Coordinates unwrapped
        let mut acc = Vec::new();
        for s in 0..=stride {
            if let Some(next_coord) = self.next_coordinate(start, s, d) {
                acc.push(next_coord);
            } else {
                return None;
            }
        }

        if !acc.is_empty() {
            Some(acc)
        } else {
            None
        }
    }

    fn product(&self, start: &Coordinate, stride: usize, d: &Direction) -> Option<u64> {
        if let Some(coordinates) = self.coordinates_for_stride(start, stride, d) {
            let product = coordinates.iter().fold(1u64, |acc, c| {
                acc * u64::from(self.value(c).expect("safe-unwrap: coordinates valid"))
            });

            return Some(product);
        };

        None
    }
}

fn main() {
    let fns = [
        problem_one,
        problem_two,
        problem_three,
        problem_four,
        problem_five,
        problem_six,
        problem_seven,
        problem_eight,
        problem_nine,
        problem_ten,
        problem_eleven
    ];

    let res: Vec<String> = fns
        .into_par_iter()
        .enumerate()
        .map(|(i, v)| format!("{:2} => {}", i + 1, v()))
        .collect();

    for s in res {
        println!("{}", s);
    }
}
